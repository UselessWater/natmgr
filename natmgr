#!/bin/bash

# NAT Manager - Linux NAT Port Forwarding Management Tool
# A simplified wrapper for iptables with interactive menu and CLI support

# Set secure umask for all file operations
umask 077

# Color definitions
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
NC='\033[0m'

# Constants
CONFIG_FILE="/etc/nat-manager.conf"
CONFIG_FILE_V6="/etc/nat-manager.conf.v6"
LOG_FILE="/var/log/nat-manager.log"
BACKUP_DIR="/etc/nat-manager.conf.d"
MAX_BACKUPS=5
LOCK_DIR="/var/run/natmgr.lock"

# IPv6 support flag
USE_IPV6=0
IPT_CMD="iptables"
IP6T_CMD="ip6tables"

# Temporary files (will be set by mktemp)
TEMP_V4=""
TEMP_V6=""

# Cleanup function for temporary files
cleanup_temp_files() {
    if [ -n "$TEMP_V4" ] && [ -f "$TEMP_V4" ]; then
        rm -f "$TEMP_V4"
    fi
    if [ -n "$TEMP_V6" ] && [ -f "$TEMP_V6" ]; then
        rm -f "$TEMP_V6"
    fi
}

# Acquire lock to prevent concurrent operations (using mkdir for atomicity)
acquire_lock() {
    local timeout=10
    local wait=0

    while true; do
        # Use mkdir for atomic lock acquisition
        if mkdir "$LOCK_DIR" 2>/dev/null; then
            echo $$ > "$LOCK_DIR/pid"
            return 0
        fi

        if [ $wait -ge $timeout ]; then
            echo -e "${RED}错误：无法获取锁，另一个 natmgr 实例正在运行${NC}" >&2
            exit 1
        fi
        sleep 0.5
        wait=$((wait + 1))
    done
}

# Release lock
release_lock() {
    if [ -n "$LOCK_DIR" ] && [ -d "$LOCK_DIR" ]; then
        rm -rf "$LOCK_DIR"
    fi
}

# Check root privileges
check_root() {
    if [ "$EUID" -ne 0 ]; then
        echo -e "${RED}错误：需要使用 root 权限运行${NC}"
        exit 1
    fi
}

# Check required dependencies
check_dependencies() {
    local missing_deps=""

    # Required commands
    for cmd in iptables mktemp grep sed awk tr mkdir rm mv; do
        if ! command -v "$cmd" >/dev/null 2>&1; then
            missing_deps="$missing_deps $cmd"
        fi
    done

    if [ -n "$missing_deps" ]; then
        echo -e "${RED}错误：缺少必要的依赖命令:$missing_deps${NC}"
        exit 1
    fi
}

# Logging function with error handling and rotation
log_msg() {
    local msg="$1"
    local max_log_size=10485760  # 10MB

    # Sanitize message: remove control characters and newlines to prevent log injection
    msg=$(printf '%s' "$msg" | tr -d '\n\r' | sed 's/[[:cntrl:]]//g')
    local log_entry="[$(date '+%Y-%m-%d %H:%M:%S')] $msg"

    # Check log file size and rotate if needed
    if [ -f "$LOG_FILE" ]; then
        local log_size
        # Try GNU stat first (Linux), then BSD stat (macOS)
        log_size=$(stat -c "%s" "$LOG_FILE" 2>/dev/null) || log_size=$(stat -f "%z" "$LOG_FILE" 2>/dev/null) || log_size=0
        if [ "$log_size" -gt "$max_log_size" ]; then
            # Rotate log: move .old to .older, current to .old
            if [ -f "${LOG_FILE}.old" ]; then
                mv "${LOG_FILE}.old" "${LOG_FILE}.older" 2>/dev/null
            fi
            mv "$LOG_FILE" "${LOG_FILE}.old" 2>/dev/null
        fi
    fi

    # Try to write to log file
    if ! printf '%s\n' "$log_entry" >> "$LOG_FILE" 2>/dev/null; then
        # If log file write fails, output to stderr
        printf '%s\n' "${YELLOW}警告：无法写入日志文件 $LOG_FILE${NC}" >&2
        printf '%s\n' "$log_entry" >&2
    fi
}

# Maximum input length for safety
MAX_INPUT_LENGTH=256

# Sanitize input - limit length and remove dangerous characters
sanitize_input() {
    local input="$1"
    # Truncate to max length
    if [ "${#input}" -gt "$MAX_INPUT_LENGTH" ]; then
        input="${input:0:$MAX_INPUT_LENGTH}"
    fi
    # Remove null bytes and control characters
    input=$(printf '%s' "$input" | tr -d '\0' | sed 's/[[:cntrl:]]//g')
    printf '%s\n' "$input"
}

# Validate protocol
validate_protocol() {
    local proto="$1"
    # Check length first
    if [ "${#proto}" -gt 10 ]; then
        return 1
    fi
    case "$proto" in
        tcp|udp|both) return 0 ;;
        *) return 1 ;;
    esac
}

# Validate port range (single port or range)
validate_port_range() {
    local port_range="$1"
    local min_port=1
    local max_port=65535

    # Check format: single port or range
    if echo "$port_range" | grep -qE '^[0-9]+-[0-9]+$'; then
        local start_port
        local end_port
        start_port=$(echo "$port_range" | cut -d'-' -f1)
        end_port=$(echo "$port_range" | cut -d'-' -f2)

        # Check range validity
        if [ "$start_port" -lt "$min_port" ] || [ "$start_port" -gt "$max_port" ]; then
            echo -e "${RED}错误：起始端口必须在 1-65535 范围内${NC}" >&2
            return 1
        fi
        if [ "$end_port" -lt "$min_port" ] || [ "$end_port" -gt "$max_port" ]; then
            echo -e "${RED}错误：结束端口必须在 1-65535 范围内${NC}" >&2
            return 1
        fi
        if [ "$start_port" -ge "$end_port" ]; then
            echo -e "${RED}错误：起始端口必须小于结束端口${NC}" >&2
            return 1
        fi
        return 0
    elif echo "$port_range" | grep -qE '^[0-9]+$'; then
        # Single port validation
        if [ "$port_range" -lt "$min_port" ] || [ "$port_range" -gt "$max_port" ]; then
            echo -e "${RED}错误：端口必须在 1-65535 范围内${NC}" >&2
            return 1
        fi
        return 0
    else
        echo -e "${RED}错误：端口格式无效（应为单个端口如 8080 或范围如 20000-30000）${NC}" >&2
        return 1
    fi
}

# Validate IPv4 address
validate_ip() {
    local ip="$1"
    local IFS='.'
    # shellcheck disable=SC2206
    local octets=($ip)

    # Check if we have exactly 4 octets
    if [ ${#octets[@]} -ne 4 ]; then
        return 1
    fi

    # Validate each octet
    local octet
    for octet in "${octets[@]}"; do
        # Check if octet is numeric
        if ! echo "$octet" | grep -qE '^[0-9]+$'; then
            return 1
        fi
        # Check range 0-255
        if [ "$octet" -lt 0 ] || [ "$octet" -gt 255 ]; then
            return 1
        fi
        # Check for leading zeros (except for 0 itself)
        if [ ${#octet} -gt 1 ] && [ "${octet%${octet#?}}" = "0" ]; then
            return 1
        fi
    done

    return 0
}

# Validate IPv6 address (basic validation)
validate_ipv6() {
    local ip="$1"

    # Remove zone index if present
    ip="${ip%%\%*}"

    # Check for empty string
    if [ -z "$ip" ]; then
        return 1
    fi

    # Handle compressed notation (::)
    local compressed_count
    compressed_count=$(echo "$ip" | grep -o '::' | wc -l)
    if [ "$compressed_count" -gt 1 ]; then
        return 1
    fi

    # Count groups (non-empty hex groups)
    local group_count
    if echo "$ip" | grep -q '::'; then
        # Compressed form - count actual hex groups (excluding the ::)
        # Remove :: and count remaining groups
        local normalized
        normalized=$(echo "$ip" | sed 's/::/:/')
        # Count non-empty hex groups
        group_count=$(echo "$normalized" | tr ':' '\n' | grep -c '^[0-9a-fA-F]\+$' || echo 0)
        # Compressed form must have 1-7 groups (at least one group must be compressed)
        if [ "$group_count" -lt 1 ] || [ "$group_count" -gt 7 ]; then
            return 1
        fi
    else
        # Full form - must have exactly 7 colons (8 groups)
        group_count=$(echo "$ip" | tr ':' '\n' | grep -c '^[0-9a-fA-F]\+$' || echo 0)
        if [ "$group_count" -ne 8 ]; then
            return 1
        fi
    fi

    # Check each group is valid hex (1-4 chars)
    local group
    while IFS= read -r group; do
        if [ -n "$group" ]; then
            if ! echo "$group" | grep -qE '^[0-9a-fA-F]{1,4}$'; then
                return 1
            fi
        fi
    done <<EOF
$(echo "$ip" | tr ':' '\n')
EOF

    return 0
}

# Validate IP address (IPv4 or IPv6 based on mode)
validate_ip_addr() {
    local ip="$1"
    if [ "$USE_IPV6" -eq 1 ]; then
        validate_ipv6 "$ip"
    else
        validate_ip "$ip"
    fi
}

# Validate destination format (IP:port or :port)
validate_destination() {
    local dst="$1"
    local port
    local ip

    if echo "$dst" | grep -qE '^:[0-9]+$'; then
        # Local port forwarding (:port)
        port="${dst#:}"
        if [ "$port" -lt 1 ] || [ "$port" -gt 65535 ]; then
            echo -e "${RED}错误：目标端口必须在 1-65535 范围内${NC}"
            return 1
        fi
        return 0
    elif echo "$dst" | grep -qE '^\[([0-9a-fA-F:]+)\]:[0-9]+$'; then
        # IPv6 [addr]:port format (strict: requires both brackets)
        ip=$(echo "$dst" | sed 's/^\[\([^]]*\)\]:.*/\1/')
        port=$(echo "$dst" | sed 's/.*\]://')

        if ! validate_ipv6 "$ip"; then
            echo -e "${RED}错误：IPv6 地址格式无效${NC}"
            return 1
        fi
        if [ "$port" -lt 1 ] || [ "$port" -gt 65535 ]; then
            echo -e "${RED}错误：目标端口必须在 1-65535 范围内${NC}"
            return 1
        fi
        return 0
    elif echo "$dst" | grep -qE '^([0-9]+\.[0-9]+\.[0-9]+\.[0-9]+):([0-9]+)$'; then
        # IPv4 IP:port format
        ip=$(echo "$dst" | cut -d':' -f1)
        port=$(echo "$dst" | cut -d':' -f2)

        if ! validate_ip "$ip"; then
            echo -e "${RED}错误：IP 地址格式无效${NC}"
            return 1
        fi
        if [ "$port" -lt 1 ] || [ "$port" -gt 65535 ]; then
            echo -e "${RED}错误：目标端口必须在 1-65535 范围内${NC}"
            return 1
        fi
        return 0
    else
        echo -e "${RED}错误：目标格式无效（应为 :port, IP:port 或 [IPv6]:port）${NC}"
        return 1
    fi
}

# Check if a rule already exists
rule_exists() {
    local proto="$1"
    local src_port="$2"
    local dst="$3"
    local src_fmt
    src_fmt="${src_port//-/:}"

    local ipt_cmd="$IPT_CMD"
    if [ "$USE_IPV6" -eq 1 ]; then
        ipt_cmd="$IP6T_CMD"
    fi

    if [ "$proto" = "both" ]; then
        # Check both tcp and udp
        if "$ipt_cmd" -t nat -C PREROUTING -p tcp --dport "$src_fmt" -j DNAT --to-destination "$dst" 2>/dev/null; then
            return 0
        fi
        if "$ipt_cmd" -t nat -C PREROUTING -p udp --dport "$src_fmt" -j DNAT --to-destination "$dst" 2>/dev/null; then
            return 0
        fi
    else
        if "$ipt_cmd" -t nat -C PREROUTING -p "$proto" --dport "$src_fmt" -j DNAT --to-destination "$dst" 2>/dev/null; then
            return 0
        fi
    fi
    return 1
}

# Check if source port is already in use by local service
check_port_in_use() {
    local port_range="$1"
    local check_port

    # Extract single port or start of range
    check_port="$port_range"
    if echo "$port_range" | grep -qE '^[0-9]+-'; then
        check_port=$(echo "$port_range" | cut -d'-' -f1)
    fi

    # Check if ss or netstat is available
    if command -v ss >/dev/null 2>&1; then
        # Check TCP port using exact match with word boundary
        if ss -tuln 2>/dev/null | awk '{print $4}' | grep -Eq ":${check_port}$"; then
            return 0
        fi
        # Check UDP port using exact match with word boundary
        if ss -ulpn 2>/dev/null | awk '{print $4}' | grep -Eq ":${check_port}$"; then
            return 0
        fi
    elif command -v netstat >/dev/null 2>&1; then
        # Check TCP port using exact match with word boundary
        if netstat -tuln 2>/dev/null | awk '{print $4}' | grep -Eq ":${check_port}$"; then
            return 0
        fi
        # Check UDP port using exact match with word boundary
        if netstat -ulpn 2>/dev/null | awk '{print $4}' | grep -Eq ":${check_port}$"; then
            return 0
        fi
    fi
    return 1
}

# Check if MASQUERADE rule exists
check_masquerade() {
    local ipt_cmd="$IPT_CMD"
    if [ "$USE_IPV6" -eq 1 ]; then
        ipt_cmd="$IP6T_CMD"
    fi

    if ! "$ipt_cmd" -t nat -L POSTROUTING 2>/dev/null | grep -q MASQUERADE; then
        if ! "$ipt_cmd" -t nat -L POSTROUTING 2>/dev/null | grep -q SNAT; then
            return 1
        fi
    fi
    return 0
}

# Apply iptables rule (common function)
apply_rule() {
    local proto="$1"
    local src_port="$2"
    local to_dest="$3"
    local src_fmt
    src_fmt="${src_port//-/:}"

    local ipt_cmd="$IPT_CMD"
    if [ "$USE_IPV6" -eq 1 ]; then
        ipt_cmd="$IP6T_CMD"
    fi

    local add_failed=0

    if [ "$proto" = "both" ]; then
        # Remove existing rule if any (suppress error)
        "$ipt_cmd" -t nat -D PREROUTING -p tcp --dport "$src_fmt" -j DNAT --to-destination "$to_dest" 2>/dev/null
        "$ipt_cmd" -t nat -D PREROUTING -p udp --dport "$src_fmt" -j DNAT --to-destination "$to_dest" 2>/dev/null
        # Add new rules
        if ! "$ipt_cmd" -t nat -A PREROUTING -p tcp --dport "$src_fmt" -j DNAT --to-destination "$to_dest" 2>/dev/null; then
            add_failed=1
        fi
        if ! "$ipt_cmd" -t nat -A PREROUTING -p udp --dport "$src_fmt" -j DNAT --to-destination "$to_dest" 2>/dev/null; then
            add_failed=1
        fi
    else
        # Remove existing rule if any (suppress error)
        "$ipt_cmd" -t nat -D PREROUTING -p "$proto" --dport "$src_fmt" -j DNAT --to-destination "$to_dest" 2>/dev/null
        # Add new rule
        if ! "$ipt_cmd" -t nat -A PREROUTING -p "$proto" --dport "$src_fmt" -j DNAT --to-destination "$to_dest" 2>/dev/null; then
            add_failed=1
        fi
    fi

    return $add_failed
}

# List rules
list_rules() {
    local ipt_cmd="$IPT_CMD"
    if [ "$USE_IPV6" -eq 1 ]; then
        ipt_cmd="$IP6T_CMD"
    fi

    echo -e "${BLUE}=== 当前 NAT 端口转发规则 ===${NC}\n"

    local rules
    rules=$("$ipt_cmd" -t nat -L PREROUTING -n --line-numbers 2>/dev/null | grep "DNAT")

    if [ -z "$rules" ]; then
        echo -e "${YELLOW}暂无转发规则${NC}"
        return 1
    fi

    printf "${GREEN}%-5s %-8s %-18s %-15s %-10s %-10s${NC}\n" "序号" "协议" "源端口范围" "目标" "目标端口" "数据包"
    echo "-------------------------------------------------------------------"

    echo "$rules" | while IFS= read -r line; do
        local num
        local pkts
        local proto
        local src_port
        local to_dest
        local dst_ip
        local dst_port

        num=$(echo "$line" | awk '{print $1}')
        pkts=$(echo "$line" | awk '{print $2}')

        # Extract protocol (tcp/udp) - without using -P
        proto="unknown"
        if echo "$line" | grep -q " udp "; then
            proto="udp"
        elif echo "$line" | grep -q " tcp "; then
            proto="tcp"
        fi

        # Extract source port - without using -P
        src_port=""
        if echo "$line" | grep -q "dpts:"; then
            src_port=$(echo "$line" | sed 's/.*dpts:\s*\([0-9]\+:[0-9]\+\).*/\1/')
        elif echo "$line" | grep -q "dpt:"; then
            src_port=$(echo "$line" | sed 's/.*dpt:\s*\([0-9]\+\).*/\1/')
        fi

        # Extract destination - without using -P
        to_dest=$(echo "$line" | sed 's/.*to:\s*\([^ ]\+\).*/\1/')
        dst_ip="本机"
        dst_port=""

        if echo "$to_dest" | grep -q '^:'; then
            # Local port forwarding (:port)
            dst_port=$(echo "$to_dest" | sed 's/^://')
        elif echo "$to_dest" | grep -q '^\['; then
            # IPv6 format: [addr]:port
            dst_ip=$(echo "$to_dest" | sed 's/^\[\([^]]*\)\]:.*/\1/')
            dst_port=$(echo "$to_dest" | sed 's/.*\]://')
        elif echo "$to_dest" | grep -q ':'; then
            # IPv4 format: ip:port
            dst_ip=$(echo "$to_dest" | cut -d':' -f1)
            dst_port=$(echo "$to_dest" | cut -d':' -f2)
            [ -z "$dst_ip" ] && dst_ip="本机"
        else
            dst_port="$to_dest"
        fi

        # Clean whitespace
        src_port=$(echo "$src_port" | tr -d '[:space:]')
        dst_port=$(echo "$dst_port" | tr -d '[:space:]')

        printf "%-5s %-8s %-18s %-15s %-10s %-10s\n" "$num" "$proto" "$src_port" "$dst_ip" "$dst_port" "$pkts"
    done

    echo ""
    echo -e "${CYAN}提示：使用 'del <序号>' 删除，'save' 保存配置${NC}"
    return 0
}

# Add rule (interactive)
add_rule() {
    local proto=""
    local src_port=""
    local dst_type=""
    local dst_port=""
    local dst_ip=""
    local to_dest=""
    local desc=""

    echo -e "${BLUE}=== 添加端口转发规则 ===${NC}\n"

    echo "选择协议："
    echo "1) TCP"
    echo "2) UDP"
    echo "3) TCP + UDP"
    read -rp "请输入 [1-3]: " proto_choice

    case $proto_choice in
        1) proto="tcp" ;;
        2) proto="udp" ;;
        3) proto="both" ;;
        *) echo -e "${RED}无效选择${NC}"; return ;;
    esac

    read -rp "请输入源端口（如：20000-30000 或 8080）: " src_port

    if ! validate_port_range "$src_port"; then
        return
    fi

    # Check if port is already in use locally
    if check_port_in_use "$src_port"; then
        echo -e "${YELLOW}警告：源端口 $src_port 可能已被本机服务占用${NC}"
        read -rp "是否继续? [y/N]: " continue_anyway
        case "$continue_anyway" in
            [Yy]*) ;;
            *) return ;;
        esac
    fi

    echo -e "\n选择目标类型："
    echo "1) 转发到本机其他端口"
    echo "2) 转发到其他服务器"
    read -rp "请输入 [1-2]: " dst_type

    if [ "$dst_type" = "1" ]; then
        read -rp "请输入目标端口（如：12345）: " dst_port

        if ! echo "$dst_port" | grep -qE '^[0-9]+$' || [ "$dst_port" -lt 1 ] || [ "$dst_port" -gt 65535 ]; then
            echo -e "${RED}错误：目标端口无效（1-65535）${NC}"
            return
        fi

        to_dest=":$dst_port"
        desc="本机:$dst_port"

    elif [ "$dst_type" = "2" ]; then
        read -rp "请输入目标 IP: " dst_ip
        read -rp "请输入目标端口: " dst_port

        if ! validate_ip_addr "$dst_ip"; then
            echo -e "${RED}错误：IP 格式无效${NC}"
            return
        fi

        if ! echo "$dst_port" | grep -qE '^[0-9]+$' || [ "$dst_port" -lt 1 ] || [ "$dst_port" -gt 65535 ]; then
            echo -e "${RED}错误：目标端口无效（1-65535）${NC}"
            return
        fi

        # Format destination based on IP version
        if [ "$USE_IPV6" -eq 1 ]; then
            to_dest="[$dst_ip]:$dst_port"
        else
            to_dest="$dst_ip:$dst_port"
        fi
        desc="$dst_ip:$dst_port"
    else
        echo -e "${RED}无效选择${NC}"
        return
    fi

    local src_fmt
    src_fmt="${src_port//-/:}"

    # Check for duplicate rule
    if rule_exists "$proto" "$src_port" "$to_dest"; then
        echo -e "${YELLOW}警告：相同规则已存在${NC}"
        read -rp "是否继续添加? [y/N]: " continue_dup
        case "$continue_dup" in
            [Yy]*) ;;
            *) return ;;
        esac
    fi

    # Check for MASQUERADE warning
    if ! check_masquerade; then
        echo -e "${YELLOW}警告：未检测到 MASQUERADE/SNAT 规则${NC}"
        echo -e "${YELLOW}       转发到内网的目标可能需要 POSTROUTING 链的 MASQUERADE 规则才能正常工作${NC}"
        echo -e "${CYAN}       示例: iptables -t nat -A POSTROUTING -j MASQUERADE${NC}"
        echo ""
    fi

    echo -e "\n${YELLOW}规则预览：${NC}"
    if [ "$proto" = "both" ]; then
        echo "  $src_port (TCP+UDP) → $desc"
    else
        echo "  $src_port ($proto) → $desc"
    fi

    read -rp "确认添加? [Y/n]: " confirm
    case "$confirm" in
        [Nn]*) return ;;
    esac

    # Execute add using common function
    if ! apply_rule "$proto" "$src_port" "$to_dest"; then
        echo -e "${RED}✗ 添加规则失败（请检查 iptables 是否正常工作）${NC}"
        return
    fi

    if [ "$proto" = "both" ]; then
        log_msg "添加规则: $src_port/tcp+udp -> $to_dest"
        echo -e "${GREEN}✓ 已添加 TCP + UDP 转发规则${NC}"
    else
        log_msg "添加规则: $src_port/$proto -> $to_dest"
        echo -e "${GREEN}✓ 已添加 $proto 转发规则${NC}"
    fi

    # Ask to save
    read -rp "是否保存到配置文件（重启后自动恢复）? [y/N]: " save_conf
    case "$save_conf" in
        [Yy]*) save_rules ;;
    esac
}

# Delete rule (interactive)
del_rule() {
    echo -e "${BLUE}=== 删除端口转发规则 ===${NC}\n"

    if ! list_rules; then
        return
    fi

    echo ""
    read -rp "请输入要删除的规则序号（多个用空格分隔，all=全部）: " nums

    if [ "$nums" = "all" ]; then
        read -rp "确定删除所有规则? [y/N]: " confirm
        case "$confirm" in
            [Yy]*)
                local ipt_cmd="$IPT_CMD"
                if [ "$USE_IPV6" -eq 1 ]; then
                    ipt_cmd="$IP6T_CMD"
                fi
                "$ipt_cmd" -t nat -F PREROUTING 2>/dev/null
                log_msg "删除所有规则"
                echo -e "${GREEN}✓ 已清空所有规则${NC}"
                ;;
        esac
        return
    fi

    # Validate all numbers first before deleting
    local valid_nums=""
    local invalid_nums=""
    local num

    for num in $nums; do
        if echo "$num" | grep -qE '^[0-9]+$'; then
            valid_nums="$valid_nums $num"
        else
            invalid_nums="$invalid_nums $num"
        fi
    done

    if [ -n "$invalid_nums" ]; then
        echo -e "${RED}错误：无效的序号: $invalid_nums${NC}"
        return
    fi

    local ipt_cmd="$IPT_CMD"
    if [ "$USE_IPV6" -eq 1 ]; then
        ipt_cmd="$IP6T_CMD"
    fi

    # Delete in reverse order to avoid index shifting
    for num in $(echo "$valid_nums" | tr ' ' '\n' | sort -rn); do
        if "$ipt_cmd" -t nat -D PREROUTING "$num" 2>/dev/null; then
            echo -e "${GREEN}✓ 已删除规则 #$num${NC}"
            log_msg "删除规则 #$num"
        else
            echo -e "${RED}✗ 规则 #$num 不存在${NC}"
        fi
    done
}

# Backup configuration before save
backup_config() {
    if [ ! -d "$BACKUP_DIR" ]; then
        mkdir -p "$BACKUP_DIR"
        chmod 700 "$BACKUP_DIR"
    fi

    # Backup IPv4 config
    if [ -f "$CONFIG_FILE" ]; then
        local backup_file_v4
        backup_file_v4="${BACKUP_DIR}/nat-manager.conf.$(date +%s)"
        cp "$CONFIG_FILE" "$backup_file_v4"
        chmod 600 "$backup_file_v4"
    fi

    # Backup IPv6 config
    if [ -f "$CONFIG_FILE_V6" ]; then
        local backup_file_v6
        backup_file_v6="${BACKUP_DIR}/nat-manager.conf.v6.$(date +%s)"
        cp "$CONFIG_FILE_V6" "$backup_file_v6"
        chmod 600 "$backup_file_v6"
    fi

    # Keep only the most recent MAX_BACKUPS backups for each type
    # Use [0-9]* pattern to only match numeric suffixes (avoid matching .v6.*)
    local backup_count_v4
    local backup_count_v6
    backup_count_v4=$(ls -1t "${BACKUP_DIR}/nat-manager.conf."[0-9]* 2>/dev/null | wc -l)
    backup_count_v6=$(ls -1t "${BACKUP_DIR}/nat-manager.conf.v6."[0-9]* 2>/dev/null | wc -l)

    if [ "$backup_count_v4" -gt "$MAX_BACKUPS" ]; then
        ls -1t "${BACKUP_DIR}/nat-manager.conf."[0-9]* 2>/dev/null | tail -n +$((MAX_BACKUPS + 1)) | xargs -r rm -f
    fi
    if [ "$backup_count_v6" -gt "$MAX_BACKUPS" ]; then
        ls -1t "${BACKUP_DIR}/nat-manager.conf.v6."[0-9]* 2>/dev/null | tail -n +$((MAX_BACKUPS + 1)) | xargs -r rm -f
    fi

    echo -e "${CYAN}已创建配置备份${NC}"
}

# Save rules
save_rules() {
    local v4_count=0
    local v6_count=0

    echo -e "${BLUE}=== 保存规则到配置文件 ===${NC}"

    # Create backup first
    backup_config

    # Use mktemp for secure temporary files in /tmp
    TEMP_V4=$(mktemp -t natmgr.conf.v4.XXXXXX) || { echo -e "${RED}错误：无法创建临时文件${NC}"; return 1; }
    TEMP_V6=$(mktemp -t natmgr.conf.v6.XXXXXX) || { rm -f "$TEMP_V4"; echo -e "${RED}错误：无法创建临时文件${NC}"; return 1; }

    # Save IPv4 rules to temp file first (atomic write)
    {
        echo "# NAT Manager Config - $(date '+%Y-%m-%d %H:%M:%S')"
        echo "# Generated by natmgr"
        echo "# IPv4 Rules"
        echo "*nat"
        echo ":PREROUTING ACCEPT [0:0]"
        "$IPT_CMD" -t nat -S PREROUTING | grep DNAT | sed 's/^-A /-A PREROUTING /'
        echo "COMMIT"
    } > "$TEMP_V4"

    if [ -s "$TEMP_V4" ]; then
        v4_count=$(grep -c "DNAT" "$TEMP_V4" 2>/dev/null || echo 0)
        # Atomic move
        mv "$TEMP_V4" "$CONFIG_FILE"
        chmod 600 "$CONFIG_FILE"
    else
        rm -f "$TEMP_V4"
        TEMP_V4=""
    fi

    # Save IPv6 rules separately (if ip6tables is available)
    if command -v ip6tables >/dev/null 2>&1; then
        local ip6t_rules
        ip6t_rules=$("$IP6T_CMD" -t nat -S PREROUTING 2>/dev/null | grep DNAT)
        if [ -n "$ip6t_rules" ]; then
            {
                echo "# NAT Manager Config - $(date '+%Y-%m-%d %H:%M:%S')"
                echo "# Generated by natmgr"
                echo "# IPv6 Rules"
                echo "*nat"
                echo ":PREROUTING ACCEPT [0:0]"
                echo "$ip6t_rules" | sed 's/^-A /-A PREROUTING /'
                echo "COMMIT"
            } > "$TEMP_V6"
            v6_count=$(echo "$ip6t_rules" | wc -l)
            # Atomic move
            mv "$TEMP_V6" "$CONFIG_FILE_V6"
            chmod 600 "$CONFIG_FILE_V6"
        else
            # Remove IPv6 config if no rules
            rm -f "$CONFIG_FILE_V6"
        fi
    fi

    # Clear temp file tracking since they're moved/deleted
    TEMP_V4=""
    TEMP_V6=""

    # Report results
    if [ "$v4_count" -gt 0 ] || [ "$v6_count" -gt 0 ]; then
        echo -e "${GREEN}✓ 已保存规则:${NC}"
        [ "$v4_count" -gt 0 ] && echo -e "  IPv4: $v4_count 条规则到 $CONFIG_FILE"
        [ "$v6_count" -gt 0 ] && echo -e "  IPv6: $v6_count 条规则到 $CONFIG_FILE_V6"
        log_msg "保存规则: IPv4=$v4_count, IPv6=$v6_count"

        echo -e "${CYAN}配置文件预览（IPv4）：${NC}"
        head -5 "$CONFIG_FILE"
        local line_count
        line_count=$(wc -l < "$CONFIG_FILE")
        [ "$line_count" -gt 5 ] && echo "... 共 $line_count 行"
    else
        echo -e "${YELLOW}没有规则可保存${NC}"
    fi
}

# Load rules
load_rules() {
    local v4_success=0
    local v6_success=0

    echo -e "${BLUE}=== 从配置文件恢复规则 ===${NC}"

    if [ ! -f "$CONFIG_FILE" ] && [ ! -f "$CONFIG_FILE_V6" ]; then
        echo -e "${RED}错误：配置文件不存在${NC}"
        echo -e "${YELLOW}提示：先使用 'save' 命令保存当前规则${NC}"
        return 1
    fi

    # Show preview of IPv4 rules
    if [ -f "$CONFIG_FILE" ]; then
        echo -e "${CYAN}IPv4 配置文件内容预览：${NC}"
        grep "DNAT" "$CONFIG_FILE" | head -3
        local v4_total
        v4_total=$(grep -c "DNAT" "$CONFIG_FILE")
        [ "$v4_total" -gt 3 ] && echo "... 共 $v4_total 条规则"
        echo ""
    fi

    # Show preview of IPv6 rules
    if [ -f "$CONFIG_FILE_V6" ]; then
        echo -e "${CYAN}IPv6 配置文件内容预览：${NC}"
        grep "DNAT" "$CONFIG_FILE_V6" | head -3
        local v6_total
        v6_total=$(grep -c "DNAT" "$CONFIG_FILE_V6")
        [ "$v6_total" -gt 3 ] && echo "... 共 $v6_total 条规则"
        echo ""
    fi

    read -rp "是否先清空现有规则? [y/N]: " flush_first
    case "$flush_first" in
        [Yy]*)
            "$IPT_CMD" -t nat -F PREROUTING
            if command -v ip6tables >/dev/null 2>&1; then
                "$IP6T_CMD" -t nat -F PREROUTING 2>/dev/null
            fi
            echo -e "${YELLOW}已清空现有规则${NC}"
            ;;
    esac

    # Restore IPv4 rules
    if [ -f "$CONFIG_FILE" ]; then
        if iptables-restore -n < "$CONFIG_FILE" 2>/dev/null; then
            echo -e "${GREEN}✓ IPv4 规则恢复成功${NC}"
            v4_success=1
        else
            echo -e "${RED}✗ IPv4 规则恢复失败${NC}"
        fi
    fi

    # Restore IPv6 rules
    if [ -f "$CONFIG_FILE_V6" ] && command -v ip6tables-restore >/dev/null 2>&1; then
        if ip6tables-restore -n < "$CONFIG_FILE_V6" 2>/dev/null; then
            echo -e "${GREEN}✓ IPv6 规则恢复成功${NC}"
            v6_success=1
        else
            echo -e "${RED}✗ IPv6 规则恢复失败${NC}"
        fi
    fi

    # Log and show results
    if [ "$v4_success" -eq 1 ] || [ "$v6_success" -eq 1 ]; then
        log_msg "从配置文件恢复规则: IPv4=$v4_success, IPv6=$v6_success"
        echo ""
        list_rules
    else
        echo -e "${RED}✗ 所有规则恢复失败${NC}"
        return 1
    fi
}

# View log
view_log() {
    echo -e "${BLUE}=== 操作日志（最近20条）===${NC}\n"
    if [ -f "$LOG_FILE" ]; then
        tail -20 "$LOG_FILE"
    else
        echo -e "${YELLOW}暂无日志记录${NC}"
    fi
}

# Uninstall
uninstall_natmgr() {
    echo -e "${RED}=== 卸载 NAT Manager ===${NC}\n"

    echo -e "${YELLOW}此操作将：${NC}"
    echo "  - 停止并禁用 nat-restore 服务"
    echo "  - 删除主程序 /usr/local/bin/natmgr"
    echo "  - 删除配置文件 /etc/nat-manager.conf"
    echo "  - 删除 IPv6 配置文件 /etc/nat-manager.conf.v6"
    echo "  - 删除日志文件 /var/log/nat-manager.log"
    echo "  - 删除 systemd 服务 /etc/systemd/system/nat-restore.service"
    echo "  - 删除配置备份目录 /etc/nat-manager.conf.d"
    echo ""
    echo -e "${YELLOW}注意：iptables 规则不会被删除${NC}"
    echo ""

    read -rp "确定要卸载吗? [y/N]: " confirm
    case "$confirm" in
        [Yy]*) ;;
        *)
            echo -e "${YELLOW}已取消卸载${NC}"
            return
            ;;
    esac

    echo ""

    # Stop and disable service
    if systemctl is-active nat-restore.service >/dev/null 2>&1; then
        echo "正在停止 nat-restore 服务..."
        systemctl stop nat-restore.service
    fi

    if systemctl is-enabled nat-restore.service >/dev/null 2>&1; then
        echo "正在禁用 nat-restore 服务..."
        systemctl disable nat-restore.service
    fi

    # Remove systemd service file
    if [ -f "/etc/systemd/system/nat-restore.service" ]; then
        echo "正在删除 systemd 服务..."
        rm -f /etc/systemd/system/nat-restore.service
        systemctl daemon-reload
    fi

    # Remove main program
    if [ -f "/usr/local/bin/natmgr" ]; then
        echo "正在删除主程序..."
        rm -f /usr/local/bin/natmgr
    fi

    # Remove config files
    if [ -f "/etc/nat-manager.conf" ]; then
        echo "正在删除配置文件..."
        rm -f /etc/nat-manager.conf
    fi

    if [ -f "/etc/nat-manager.conf.v6" ]; then
        echo "正在删除 IPv6 配置文件..."
        rm -f /etc/nat-manager.conf.v6
    fi

    # Remove log file
    if [ -f "/var/log/nat-manager.log" ]; then
        echo "正在删除日志文件..."
        rm -f /var/log/nat-manager.log
    fi

    # Remove backup directory
    if [ -d "$BACKUP_DIR" ]; then
        echo "正在删除配置备份目录..."
        rm -rf "$BACKUP_DIR"
    fi

    # Clean up lock file
    release_lock

    echo ""
    echo -e "${GREEN}=================================${NC}"
    echo -e "${GREEN}    NAT Manager 已卸载完成       ${NC}"
    echo -e "${GREEN}=================================${NC}"
    echo ""
    echo -e "${YELLOW}如需完全清理所有痕迹，请执行以下命令：${NC}"
    echo ""
    echo "  ${CYAN}# 删除残留的安装目录${NC}"
    echo "  rm -rf /path/to/natmgr/installation/directory"
    echo ""
    echo "  ${CYAN}# 清空当前 iptables NAT 规则（IPv4）${NC}"
    echo "  iptables -t nat -F PREROUTING"
    echo ""
    echo "  ${CYAN}# 清空当前 iptables NAT 规则（IPv6）${NC}"
    echo "  ip6tables -t nat -F PREROUTING"
    echo ""
    echo "  ${CYAN}# 保存 iptables 规则（如需保留当前规则）${NC}"
    echo "  iptables-save > /etc/iptables/rules.v4"
    echo "  ip6tables-save > /etc/iptables/rules.v6"
    echo ""
    echo -e "${YELLOW}提示：当前会话中 natmgr 命令仍然缓存，请执行以下命令刷新：${NC}"
    echo ""
    echo "  hash -r"
    echo ""
    echo -e "${YELLOW}或重新登录以使更改生效${NC}"
    echo ""
}

# Quick add (CLI mode)
quick_add() {
    local proto="$1"
    local src="$2"
    local dst="$3"

    # Validate protocol
    if ! validate_protocol "$proto"; then
        echo -e "${RED}错误：无效的协议 '$proto'（应为 tcp/udp/both）${NC}"
        return 1
    fi

    # Validate source port
    if ! validate_port_range "$src"; then
        return 1
    fi

    # Validate destination
    if ! validate_destination "$dst"; then
        return 1
    fi

    local to_dest
    if echo "$dst" | grep -q ':'; then
        to_dest="$dst"
    else
        to_dest=":$dst"
    fi

    # Check for duplicate
    if rule_exists "$proto" "$src" "$to_dest"; then
        echo -e "${YELLOW}警告：相同规则已存在，将更新规则${NC}"
    fi

    if ! apply_rule "$proto" "$src" "$to_dest"; then
        echo -e "${RED}✗ 添加规则失败（请检查 iptables 是否正常工作）${NC}"
        return 1
    fi

    if [ "$proto" = "both" ]; then
        echo -e "${GREEN}✓ 已添加: $src/tcp+udp -> $dst${NC}"
    else
        echo -e "${GREEN}✓ 已添加: $src/$proto -> $dst${NC}"
    fi
    log_msg "快速添加: $src/$proto -> $dst"
}

# Show menu
show_menu() {
    clear
    echo -e "${BLUE}╔════════════════════════════════════╗${NC}"
    echo -e "${BLUE}║        NAT 端口转发管理器          ║${NC}"
    echo -e "${BLUE}╚════════════════════════════════════╝${NC}"
    echo ""

    local count
    count=$("$IPT_CMD" -t nat -L PREROUTING -n 2>/dev/null | grep -c "DNAT")
    echo -e "当前规则数: ${GREEN}$count${NC}  |  配置: ${CYAN}$CONFIG_FILE${NC}"
    echo ""

    echo "  1) 查看当前规则"
    echo "  2) 添加转发规则"
    echo "  3) 删除转发规则"
    echo "  4) 保存规则配置"
    echo "  5) 恢复规则配置"
    echo "  6) 查看操作日志"
    echo "  7) 卸载脚本"
    echo "  0) 退出"
    echo ""
    read -rp "请选择操作 [0-7]: " choice

    case $choice in
        1) list_rules ;;
        2) add_rule ;;
        3) del_rule ;;
        4) save_rules ;;
        5) load_rules ;;
        6) view_log ;;
        7) uninstall_natmgr; return ;;
        0) exit 0 ;;
        *) echo -e "${RED}无效选择${NC}" ;;
    esac

    echo ""
    read -rp "按回车键继续..."
    show_menu
}

# Show help
show_help() {
    cat << 'HELP'
用法: natmgr [选项] [命令] [参数]

选项:
    -4                      使用 IPv4 (默认)
    -6                      使用 IPv6

交互模式:
    natmgr                  启动可视化菜单

快速命令:
    natmgr add              交互式添加规则
    natmgr add <协议> <源端口> <目标>    快速添加
                                        协议: tcp/udp/both
                                        目标: 端口 或 IP:端口

    natmgr del              交互式删除
    natmgr del <序号>       删除指定规则
    natmgr del all          删除所有规则 (需要确认)

    natmgr list             查看当前规则
    natmgr save             保存规则到配置文件
    natmgr load             从配置文件恢复规则
    natmgr log              查看操作日志
    natmgr uninstall        卸载 NAT Manager
    natmgr help             显示此帮助

示例:
    natmgr add udp 20000-30000 12345          # UDP转发到本机
    natmgr add tcp 8080 192.168.1.50:80       # TCP转发到内网
    natmgr add both 443 8443                  # TCP+UDP转发到本机
    natmgr del 1                              # 删除第1条规则
    natmgr del all                            # 删除所有规则 (确认后)
    natmgr save                               # 保存配置
    natmgr load                               # 重启后恢复配置
HELP
}

# Main
check_root
check_dependencies

# Acquire lock to prevent concurrent operations
acquire_lock

# Ensure lock is released on exit and other signals
trap release_lock EXIT INT TERM HUP

# Parse global options first
while [ -n "$1" ] && echo "$1" | grep -q '^-'; do
    case "$1" in
        -4)
            USE_IPV6=0
            shift
            ;;
        -6)
            USE_IPV6=1
            shift
            ;;
        *)
            break
            ;;
    esac
done

case "$1" in
    add)
        shift
        if [ $# -ge 3 ]; then
            quick_add "$@"
        else
            add_rule
        fi
        ;;
    del|delete)
        if [ -n "$2" ]; then
            if [ "$2" = "all" ]; then
                # Require confirmation for CLI mode too
                local force=0
                if [ "$3" = "-f" ] || [ "$3" = "--force" ]; then
                    force=1
                fi

                if [ "$force" -eq 0 ]; then
                    echo -e "${YELLOW}警告：此操作将删除所有 NAT 规则${NC}"
                    read -rp "确定要继续吗? [y/N]: " confirm
                    case "$confirm" in
                        [Yy]*) ;;
                        *)
                            echo -e "${YELLOW}已取消${NC}"
                            exit 0
                            ;;
                    esac
                fi

                local ipt_cmd
                ipt_cmd="$IPT_CMD"
                if [ "$USE_IPV6" -eq 1 ]; then
                    ipt_cmd="$IP6T_CMD"
                fi
                "$ipt_cmd" -t nat -F PREROUTING
                log_msg "删除所有规则"
                echo -e "${GREEN}✓ 已清空所有规则${NC}"
            else
                local ipt_cmd
                ipt_cmd="$IPT_CMD"
                if [ "$USE_IPV6" -eq 1 ]; then
                    ipt_cmd="$IP6T_CMD"
                fi
                if "$ipt_cmd" -t nat -D PREROUTING "$2" 2>/dev/null; then
                    echo -e "${GREEN}✓ 已删除规则 #$2${NC}"
                    log_msg "删除规则 #$2"
                else
                    echo -e "${RED}✗ 规则 #$2 不存在${NC}"
                    exit 1
                fi
            fi
        else
            del_rule
        fi
        ;;
    list|ls|status)
        list_rules
        ;;
    save)
        save_rules
        ;;
    load|restore)
        load_rules
        ;;
    log|logs)
        view_log
        ;;
    uninstall|remove)
        uninstall_natmgr
        ;;
    help|--help|-h)
        show_help
        ;;
    *)
        if [ -t 0 ]; then
            show_menu
        else
            show_help
        fi
        ;;
esac
